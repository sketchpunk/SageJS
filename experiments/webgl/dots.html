<!DOCTYPE html>
<html>
	<head>
		<link rel="stylesheet" type="text/css" href="../_shared/shared.css">
		<script src="../../src/sage.math.js"></script>

		<script src="../../src/sage.webgl/sage.webgl.js"></script>
		<script src="../../src/sage.webgl/sage.webgl.CanvasGL.js"></script>
		<script src="../../src/sage.webgl/sage.webgl.Shader.js"></script>
		<script src="../../src/sage.webgl/sage.webgl.CubeMesh.js"></script>
		<script>
  			var cgl,shader, vertBuf;
  			var vertices = [];
  			var vertCnt = 5000;

  			var mouseX = 0, mouseY = 0;

			window.addEventListener("load",function(){
				
				var canvas = document.getElementById("canvas01");
				canvas.addEventListener("mousemove",function(e){
					mouseX = map(e.clientX - this.offsetLeft,0,500,-1,1);  //Map canvas size to web cord system
					mouseY = map(e.clientY - this.offsetTop,0,500,1,-1);
				});


				//Prepare WebGL and Camera
				cgl = new sage.webgl.CanvasGL("canvas01")
					.setSize(500,500)
					.setBackgroundColor(0,0,0,0);

				for(var i=0; i < vertCnt; i++){
					vertices.push(Math.random() * 2 - 1); //Randome Points between -1 and 1;
					vertices.push(Math.random() * 2 - 1);
				}

				vertBuf = cgl.createArrayBuffer(vertices,false);

	
				shader = new sage.webgl.Shader(cgl);
				shader.createProgram("vertShader","fragShader",false);
				//shader.addAttribFloat("coords",0,0,0);
				shader.addAttribAryBuffer("coords",2,vertBuf);
				shader.addAttribFloat("psize",1);
				shader.addUniformFloat("color",0,1,0,1);

				draw();
			});

			function draw(){
				for(var i = 0; i < vertCnt * 2; i += 2){
					var dx = vertices[i] - mouseX,
						dy = vertices[i+1] - mouseY,
						dist = Math.sqrt( dx*dx + dy*dy );

					if(dist < 0.2){
						vertices[i] = mouseX + dx / dist * 0.2;
						vertices[i+1] = mouseY + dy / dist * 0.2;
					}else{
						vertices[i] += Math.random() * 0.01 - 0.005;  //0.005 is the center point, if number is over its positive but under becomes negative, keeps the points from floating away.
						vertices[i + 1] += Math.random() * 0.01 - 0.005;
					}
				}
				cgl.updateArrayBuffer(vertBuf,vertices);
				
				cgl.clear(); //clear the scene
				cgl.mGL.drawArrays(cgl.mGL.POINTS,0,vertCnt);
				requestAnimationFrame(draw);
			}

			function updatePoint(v){
				shader.updateAttribFloat("psize",v);
			}

			//UI control stuff
			function preview(o){ o.previousSibling.innerHTML = o.value; }

			function map(v, minFrom, maxFrom, minTo,maxTo){ return (v-minFrom) / (maxFrom-minFrom) * (maxTo-minTo) + minTo; }
		</script>
	</head>
<body>

<script id="vertShader" type="x-shader/x-vertex">
	attribute vec4 coords;
	attribute float psize;

	void main(void) {
		gl_Position = coords;
		gl_PointSize = psize;
	}
</script>

<script id="fragShader" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec4 color;
	void main(void) {
		gl_FragColor = color; //vec4(0.0, 1.0, 0.0, 1.0);
	}
</script>


<div class="rowFlex" style="width:800px; margin:0px auto;">
	<section style="width:500px;">
		<div class="NodeContainer" style="display:inline-block;">
			<header>WebGL Enabled Canvas</header>
			<canvas id="canvas01"></canvas>
		</div>
	</section>

	<section>
		<div class="NodeContainer">
			<header style="margin-bottom:20px;">Shader Control</header>
			<div class="ctrRow">
				<span>Point Size: </span><label>2</label><input id="yrot" class="slider" type="range" min="2" max="20" value="2" onInput="preview(this);" onChange="updatePoint(this.value);"/>
			</div>
		</div>
	<section>
</div>

<div class="rowFlex">
	<section>
		<p style="color:#a0a0a0; bottom:1px;">
			<i style="color:lime;">WebGL Experiments : Basics with Shaders and Points</i><br>
		

			- <a href="https://github.com/sketchpunk/SageJS" style="color:orange;text-decoration:none;">Source on Github</a><br><br>

			<br><br>&copy; 2016 Sketchpunk Labs;
		</p>
	</section>
</div>

</body>
</html>