<!DOCTYPE html>
<html>
	<head>
		<link rel="stylesheet" type="text/css" href="../_shared/shared.css">
		<script src="../../src/sage.math.js"></script>

		<script src="../../src/sage.webgl/sage.webgl.js"></script>
		<script src="../../src/sage.webgl/CanvasGL.js"></script>
		<script src="../../src/sage.webgl/Shader.js"></script>
		<script src="../../src/sage.webgl/Transform.js"></script>
		<script src="../../src/sage.webgl/CubeMesh.js"></script>
		<script>
  			var cgl,shader,camera,renderLoop,meshCube, rotX=0,rotY=0,rotZ=0;

			window.addEventListener("load",function(){
				//Prepare WebGL and Camera
				cgl = new sage.webgl.CanvasGL("canvas01")
					.setSize(500,500)
					.setBackgroundColor(0,0,0,0);

				camera  = new sage.webgl.Camera()
					.setPerspective(45,500/500,0.1,100.00);

				//Procedurally Generated Cube
				meshCube = new CubeMesh(cgl,2,2,2);
				meshCube.transform.position.z = -5;

				//Define the shader that will render the mesh
				shader = new sage.webgl.Shader(cgl);
				shader.createProgramByDom("vertShader","fragShader",false);
				shader.attribFAryBuf("aVertexPosition",3,meshCube.cubeVertBuffer);
				shader.attribFAryBuf("aVertexColor",4,meshCube.colorBuffer);
				shader.uniformMatrix4fv("model",meshCube.transform.updateMatrix());
				shader.uniformMatrix4fv("projection",camera.getPerspectiveMatrix());
				shader.uniformMatrix4fv("view",camera.updateViewMatrix());
  				
  				//Animation Loop handler
				renderLoop = new sage.webgl.RenderLoop(onDraw);
				renderLoop.start();

				//onDraw(0.1);
			});

			function onDraw(delta){
				//delta *= 0.4; //Slow down the rotation speed
				cgl.clear(); //clear the scene

				meshCube.transform.rotation.x += rotX * delta;
				meshCube.transform.rotation.y += rotY * delta;
				meshCube.transform.rotation.z += rotZ * delta;

				//Rotate the camera position then update the shader with its position.
				//camera.rotateY(rotY * delta);//.rotateZ(rotZ * delta).rotateX(rotX*delta);
				//camera.rotateY(110).rotateX(0);
				//shader.uniformMatrix4fv("model",camera.getViewMatrix());
				shader.uniformMatrix4fv("model",meshCube.transform.updateMatrix());
	
				//Render the cube.
				meshCube.draw(cgl);
			}

			//UI control stuff
			function preview(o){ o.previousSibling.innerHTML = o.value; }
			function reset(){
				var o = document.getElementById("yrot");o.value = rotY = 0; preview(o);
				o = document.getElementById("xrot");	o.value = rotX = 0; preview(o);
				o = document.getElementById("zrot");	o.value = rotZ = 0; preview(o);
				o = document.getElementById("xpos");	o.value = 0; preview(o);
				o = document.getElementById("ypos");	o.value = 0; preview(o);
				o = document.getElementById("zpos");	o.value = -5; preview(o);
				o = document.getElementById("xscale");	o.value = 1; preview(o);
				o = document.getElementById("yscale");	o.value = 1; preview(o);
				o = document.getElementById("zscale");	o.value = 1; preview(o);

				o = document.getElementById("cyrot");	o.value = 0; preview(o);
				o = document.getElementById("cxrot");	o.value = 0; preview(o);
				o = document.getElementById("czrot");	o.value = 0; preview(o);
				o = document.getElementById("cxpos");	o.value = 0; preview(o);
				o = document.getElementById("cypos");	o.value = 0; preview(o);
				o = document.getElementById("czpos");	o.value = 0; preview(o);

				meshCube.transform.reset();
				meshCube.transform.position.z = -5;

				camera.transform.reset();
				shader.uniformMatrix4fv("view",camera.updateViewMatrix());
			}

			function updateCamera(){
				camera.transform.rotation.x = document.getElementById("cxrot").value;
				camera.transform.rotation.y = document.getElementById("cyrot").value;
				camera.transform.rotation.z = document.getElementById("czrot").value;
				camera.transform.position.x = document.getElementById("cxpos").value;
				camera.transform.position.y = document.getElementById("cypos").value;
				camera.transform.position.z = document.getElementById("czpos").value;

				shader.uniformMatrix4fv("view",camera.updateViewMatrix());
			}
		</script>
	</head>
<body>

<script id="vertShader" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec4 aVertexColor;

	uniform mat4 view;
	uniform mat4 model;
	uniform mat4 projection;

	varying lowp vec4 vColor;

	void main(void) {
		gl_Position = projection * view * model * vec4(aVertexPosition, 1.0);
		vColor = aVertexColor;
	}
</script>

<script id="fragShader" type="x-shader/x-fragment">
	varying lowp vec4 vColor;
	void main(void) {
		gl_FragColor = vColor; //vec4(1.0, 1.0, 1.0, 1.0);
	}
</script>


<div class="rowFlex" style="width:1200px; margin:0px auto;">
	<section>
		<div class="NodeContainer" style="margin-bottom:15px;">
			<header style="margin-bottom:20px;">Camera Control</header>
			<div class="ctrRow">
				<span>Y Rotation: </span><label>0</label><input id="cyrot" class="slider" type="range" min="-180" max="180" value="0" onInput="preview(this);" onChange="updateCamera();"/>
			</div>
			<div class="ctrRow">
				<span>X Rotation: </span><label>0</label><input id="cxrot" class="slider" type="range" min="-180" max="180" value="0" onInput="preview(this);" onChange="updateCamera();"/>
			</div>
			<div class="ctrRow">
				<span>Z Rotation: </span><label>0</label><input id="czrot" class="slider" type="range" min="-180" max="180" value="0" onInput="preview(this);" onChange="updateCamera();"/>
			</div>

			<div class="ctrRow">
				<span>X Position: </span><label>0</label><input id="cxpos" class="slider" type="range" min="-5" max="5" value="0" step="0.1" onInput="preview(this);" onChange="updateCamera();"/>
			</div>

			<div class="ctrRow">
				<span>Y Position: </span><label>0</label><input id="cypos" class="slider" type="range" min="-5" max="5" value="0" step="0.1" onInput="preview(this);" onChange="updateCamera();"/>
			</div>

			<div class="ctrRow">
				<span>Z Position: </span><label>0</label><input id="czpos" class="slider" type="range" min="-5" max="5" value="0" step="0.1" onInput="preview(this);" onChange="updateCamera();"/>
			</div>

			<div class="ctrRow full">
				<input type="button" id="btn1" onClick="reset(); this.blur();" value="Reset All" style="display:block;">
			</div>
		</div>
	</section>	


	<section style="width:500px;">
		<div class="NodeContainer" style="display:inline-block;">
			<header>WebGL Enabled Canvas</header>
			<canvas id="canvas01"></canvas>
		</div>
	</section>

	<section>
		<div class="NodeContainer" style="margin-bottom:15px;">
			<header style="margin-bottom:20px;">Cube Animation</header>
			<div class="ctrRow">
				<span>Y Rotation: </span><label>0</label><input id="yrot" class="slider" type="range" min="0" max="180" value="0" onInput="preview(this);" onChange="rotY = this.value;"/>
			</div>
			<div class="ctrRow">
				<span>X Rotation: </span><label>0</label><input id="xrot" class="slider" type="range" min="0" max="180" value="0" onInput="preview(this);" onChange="rotX = this.value;"/>
			</div>
			<div class="ctrRow">
				<span> Z Rotation: </span><label>0</label><input id="zrot" class="slider" type="range" min="0" max="180" value="0" onInput="preview(this);" onChange="rotZ = this.value;"/>
			</div>
		</div>

		<div class="NodeContainer">
			<header style="margin-bottom:20px;">Cube Controls</header>

			<div class="ctrRow">
				<span>X Position: </span><label>0</label><input id="xpos" class="slider" type="range" min="-5" max="5" value="0" step="0.1" onInput="preview(this);" onChange="meshCube.transform.position.x = this.value"/>
			</div>

			<div class="ctrRow">
				<span>Y Position: </span><label>0</label><input id="ypos" class="slider" type="range" min="-5" max="5" value="0" step="0.1" onInput="preview(this);" onChange="meshCube.transform.position.y = this.value"/>
			</div>

			<div class="ctrRow">
				<span>Z Position: </span><label>-5</label><input id="zpos" class="slider" type="range" min="-15" max="1" value="-5" step="0.1" onInput="preview(this);" onChange="meshCube.transform.position.z = this.value"/>
			</div>


			<div class="ctrRow">
				<span>X Scale: </span><label>1</label><input id="xscale" class="slider" type="range" min="0.1" max="2" value="1" step="0.1" onInput="preview(this);" onChange="meshCube.transform.scale.x = this.value"/>
			</div>

			<div class="ctrRow">
				<span>Y Scale: </span><label>1</label><input id="yscale" class="slider" type="range" min="0.1" max="2" value="1" step="0.1" onInput="preview(this);" onChange="meshCube.transform.scale.y = this.value"/>
			</div>

			<div class="ctrRow">
				<span>Z Scale: </span><label>1</label><input id="zscale" class="slider" type="range" min="0.1" max="2" value="1" step="0.1" onInput="preview(this);" onChange="meshCube.transform.scale.z = this.value"/>
			</div>
		</div>
	</section>
</div>

<div class="rowFlex">
	<section>
		<p style="color:#a0a0a0; bottom:1px;">
			<i style="color:lime;">WebGL Experiments : Build a viewer from scratch</i><br>
			
			Wanting to move into VR and AR development, I've begun studing game and graphic programming. While I use Unity3D/Unreal engines as a way
			to learn the front end of things I'm going to use WebGL as a way to learn the backend. So the idea is to build a web based 3D modal viewer from
			scratch. So far I have a working canvas, shaders and a procedurally generated cube with random colors for each face. For demonstration I added
			controls for rotation and distance of the camera and the mesh itself.
			<br><br>

			- <a href="https://github.com/sketchpunk/SageJS" style="color:orange;text-decoration:none;">Source on Github</a><br><br>

			<br><br>&copy; 2016 Sketchpunk Labs;
		</p>
	</section>
</div>

</body>
</html>