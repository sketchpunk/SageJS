<!DOCTYPE html>
<html>
	<head>
		<style>
			html,body{margin:0px; padding:0px; width:100%; height:100%;}
			body{}
		</style>
		<script src="gl.js"></script>
		<script src="DataStructs.js"></script>
		<script src="Shader.js"></script>


		<!--
		vao basicly pre defines what buffers goes to what shader attribute, kinda like a macro.
		So the idea is to have a vao record buffer to attrib relation, then just bind the vao before drawing
		else you would need to bind the attrib for each buffer for each frame.

		Need to define default shader attributes, Vertices(Position) v3, Index int, UV v2, Normals v3. The shader will
		then have get methods to allow a mesh to setup the vao with the correct attribute indexes for
		the specific shader.
		-->

		<script>
			var gl,shader,tri;
			var m4p,m4mv;
			window.addEventListener("load",function(){				
				//......................................
				m4p = new Float32Array(16);
				Matrix4.perspective(m4p,45,500/500,0.1,100.00);
				m4mv = Matrix4.identity();
				m4mv[12] = -1.2;
				m4mv[14] = -5;

				gl = GLInstance("glcanvas")
					.fSetBackgroundColor(0,0,0,1)
					.fSetSize(500,500)
					.fClear();

				//......................................

				//......................................
				shader = new Shader(gl);
				shader.createFromDom("vertex_shader","fragment_shader",true);
				
				sqr = new Square(gl,shader);
				tri = new Triangle(gl,shader);
				
				shader.activate();
				shader.uniformMatrix4fv("uPMatrix",m4p);

				shader.uniformMatrix4fv("uMVMatrix",m4mv);
				//shader.attribFAryBuf("aVertPos",tri.vLen,tri.buf);
				tri.render(gl);

				m4mv[12] = 1.2;
				shader.uniformMatrix4fv("uMVMatrix",m4mv);
				//shader.attribFAryBuf("aVertPos",sqr.vLen,sqr.buf);
				sqr.render(gl);

				shader.deactivate();

				shader.dispose();
				tri.dispose(gl);
			});


			class Triangle{
				constructor(gl,shader){
					var verts = [
						 0.0,  1.0,  0.0,
						-1.0, -1.0,  0.0,
						 1.0, -1.0,  0.0
    				];
    				this.vLen = 3;
    				this.vCount = verts.length / this.vLen;

    				//Create and bind vao
					this.vao = gl.createVertexArray();
					gl.bindVertexArray(this.vao);

					//create buffers
    				this.posBuf = gl.fCreateArrayBuffer(verts,true);
    				gl.bindBuffer(gl.ARRAY_BUFFER,this.posBuf);

    				//assign bufs tp specific shader attributes;
    				gl.enableVertexAttribArray(0);
    				gl.vertexAttribPointer(0,3,gl.FLOAT,false, 0,0); //hardcoding attribute position 

    				gl.bindVertexArray(null);
    				gl.bindBuffer(gl.ARRAY_BUFFER,null);
				}

				dispose(gl){
					//TODO find a way to tell if the buffer and voa is currently bound, to unbind before deleting.
					gl.deleteBuffer(this.posBuf);
					gl.deleteVertexArray(this.vao);
				}

				render(gl){
					//gl.bindBuffer(gl.ARRAY_BUFFER, this.buf);
					gl.bindVertexArray(this.vao);
					gl.drawArrays(gl.TRIANGLES, 0, this.vCount);
					gl.bindVertexArray(null);
				}
			}

			class Square{
				constructor(gl){
					  var verts = [
					    1.0,  1.0,  0.0,
					    -1.0, 1.0,  0.0,
					    1.0,  -1.0, 0.0,
					    -1.0, -1.0, 0.0
					  ];
  
    				this.vLen = 3;
    				this.vCount = verts.length / this.vLen;

    				//Create and bind vao
					this.vao = gl.createVertexArray();
					gl.bindVertexArray(this.vao);

					//create buffers
    				this.posBuf = gl.fCreateArrayBuffer(verts,true);
    				gl.bindBuffer(gl.ARRAY_BUFFER,this.posBuf);

    				//assign bufs tp specific shader attributes;
    				gl.enableVertexAttribArray(0);
    				gl.vertexAttribPointer(0,3,gl.FLOAT,false, 0,0); //hardcoding attribute position 

    				gl.bindVertexArray(null);
    				gl.bindBuffer(gl.ARRAY_BUFFER,null);
				}

				render(gl){
					//gl.bindBuffer(gl.ARRAY_BUFFER, this.buf);
					gl.bindVertexArray(this.vao);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.vCount);
					gl.bindVertexArray(null);
				}
			}
		</script>
	</head>
<body>

<div style="display:flex; width:100%; height:100%; align-items:center; justify-content:center;">
	<canvas id="glcanvas"></canvas>
	<!--<div style="width:500px; height:500px; border:1px solid red;"></div>-->
</div>

<script id="vertex_shader" type="x-shader/x-vertex">#version 300 es
	in vec3 aVertPos;
	//attribute vec3 aVertPos;
	uniform mat4 uPMatrix;
	uniform mat4 uMVMatrix;

	out vec4 color;

	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertPos, 1.0);
		color = vec4(aVertPos * 0.5 + 0.5, 1.0); //-1 to 1 into 0 to 1
	}
</script>

<script id="fragment_shader" type="x-shader/x-fragment">#version 300 es
	precision mediump float;

	in vec4 color;
	
	out vec4 outColor;
	
	void main(void) {
		//gl_FragColor = color; //vec4(1.0, 1.0, 1.0, 1.0);
		outColor = color;
	}
</script>

</body>
</html>